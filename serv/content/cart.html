<!DOCTYPE html>
<html lang="en">
<head>
   <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
   <title>Cart basics</title>

   <style>
html, body {
    height: 100%;
}
#errors {
  color: red;
}

#arena {
    position: relative;
    height: 75%;
    width: 50%;
    background-image: url("grassy.jpg");
    background-size: cover;
    margin-top: 1em;
}
   </style>
   <script src="rezoom.js"></script>
   <script src="drag.js"></script>
   <script>

function phoneHome(text) {
    var url = "/phonehome/?" + encodeURI(text);
    sendAjaxGet(url);
}

function sendAjaxGet(url, okfn, errfn) {
    var errors = document.getElementById("errors");
    errors.innerText = "";
    if (!errfn) errfn = ajaxErrFn;
    var loadedfn = function loadedfn(evt) {
        if (evt.target.status !== 0 && evt.target.status !== 200) {
            errfn(evt);
        } else if (okfn) okfn(evt);
    };
    var req = new XMLHttpRequest();
    req.responseType = "text";
    req.open("GET", url);
    req.addEventListener("load", loadedfn);
    req.addEventListener("error", errfn);
    req.addEventListener("abort", errfn);
    req.send();
}

function ajaxErrFn(evt) {
    console.log("ajax error", evt.target);
    var errors = document.getElementById("errors");
    errors.innerText = "Trouble contacting server";
}

function lerp(x, x0, x1, y0, y1) {
    var frac = (x - x0) / (x1 - x0);
    var y =  y0 + frac * (y1 - y0);
    //console.log(`lerp x ${x} x0 ${x0} x1 ${x1} y0 ${y0} y1 ${y1} ==> ${y}`);
    return y;
}

function round3(x) { return Math.round(1000*x) / 1000; }

function onStart(target, x, y) {
    //console.log("onStart x", x, "y", y);
    var f = posFraction(x, y);
    maybeSendMotion(f.x, f.y);
}
function onMove(target, x, y) {
    var f = posFraction(x, y);
    maybeSendMotion(f.x, f.y);
}
function onEnd(target, x, y) {
    maybeSendMotion(0.5, 0.5);
    //sendAjaxGet("/stop");
}

var onFunctions = {onstart: onStart, onmove: onMove, onend: onEnd};

function arenaClick(evt) {
    doDrag(evt, onFunctions);
}
function arenaTouch(evt) {
    doDrag(evt, onFunctions);
}

var servoChannels = {
    throttle: 0,
    steering: 1,
};
var deadZone = { steering: {low: 0.4, high: 0.6}, throttle: {low: 0.4, high: 0.6}};

var desiredSetting = {
    steering: {direction: null, speed: 0},
    throttle: {direction: null, speed: 0}
};
var recentSetting = {
    steering: {direction: null, speed: 0},
    throttle: {direction: null, speed: 0},
    inprogress: false,
};

var fullThrottlePWM = 1.0;

function maybeSendMotion(fx, fy) {
    // fx, fy are fractions (0..1) of the way across the arena.
    // First, translate each to -1..+1
    // then combine them the motor power.
    var signed = function signed(motor, f) {
        // dead zone in the middle for each direction
        if (f < deadZone[motor].low) {
            return -lerp(f, deadZone[motor].low, 0, 0, fullThrottlePWM);
        } else if (f > deadZone[motor].high) {
	    return lerp(f, deadZone[motor].high, 1, 0, fullThrottlePWM);
        } else {
	    return 0.0;
        }
    };
    //---throttle and steering are misnomers for left-right motors
    var pthrottle = signed("throttle", fy);
    var psteering = -signed("steering", fx);
    // Add the steering to the right, subtract from left
    var pleft = pthrottle - psteering;
    var pright = pthrottle + psteering;
    pleft = round3(pleft);
    pright = round3(pright);
    pright = -pright;	// fix wiring error
    console.log(`fx ${fx} fy ${fy} pleft ${pleft} pright ${pright}`);
    // Convert back to sign-magnitude
    desiredSetting["steering"].direction = (pleft < 0)? "A" : "B";
    desiredSetting["steering"].speed = Math.min(1.0, Math.abs(pleft));
    desiredSetting["throttle"].direction = (pright < 0)? "A" : "B";
    desiredSetting["throttle"].speed = Math.min(1.0, Math.abs(pright));

    queueMotion();
}

// While a request is in progress, don't send another until the response
// to the current one comes back.
function queueMotion() {
    if (recentSetting.inprogress) {
        // Any change will be handled when the current in-progress request completes.
        //phoneHome("in progress");
        return;
    }
    var changed = false;
    rforeach(["steering", "throttle"], function(motor) {
        rforeach(["direction", "speed"], function(axis) {
            if (desiredSetting[motor][axis] != recentSetting[motor][axis]) {
                changed = true;
            } else {
                //var msg = "n/c " + motor+"."+axis + " " + desiredSetting[motor][axis] + " vs " + recentSetting[motor][axis];
                //phoneHome(msg);
            }
        });
    });
    if (!changed) {
        // ---This could keep track of when the last request went out,
        // and send out even a dup if it has been long enough (like 1.0 sec?)

        // Nothing to do
        //phoneHome("no change");
        return;
    } else {
        //phoneHome("yay change");
    }

    // direction (A or B)
    // channel (0 or 1, probably)
    // PWM value (0.0 to 1.0)
    // One triple for steering, then one for throttle
    var urlparts = function urlparts(motor) {
        var parts = [desiredSetting[motor].direction, servoChannels[motor], desiredSetting[motor].speed];
        return parts.join("-");
    };

    var steeringParts = urlparts("steering");
    var throttleParts = urlparts("throttle");
    var url = ["/motor", steeringParts, throttleParts].join("/");
    rforeach(["steering", "throttle"], function(motor) {
        rforeach(["direction", "speed"], function(axis) {
            recentSetting[motor][axis] = desiredSetting[motor][axis];
        });
    });

    recentSetting.inprogress = true;
    var okfn = function okfn(evt) {
        recentSetting.inprogress = false;
        queueMotion();
    };
    var errfn = function errfn(evt) {
        recentSetting.inprogress = false;
        ajaxErrFn(evt);
    };
    sendAjaxGet(url, okfn, errfn);
}

function posFraction(x, y) {
    var arena = document.getElementById("arena");
    var left = arena.offsetLeft;
    var top = arena.offsetTop;
    var width = arena.offsetWidth;
    var height = arena.offsetHeight;
    var dx = x - left;
    var dy = y - top;
    var fx = round3(Math.max(0.0, Math.min(1.0, dx * 1.0 / width)));
    var fy = round3(Math.max(0.0, Math.min(1.0, dy * 1.0 / height)));
    //console.log("left", left, "top", top, "width", width, "height", height);
    //console.log("x", x, "y", y, "dx", dx, "dy", dy, "fx", fx, "fy", fy);
    return {x: fx, y: fy};
}

   </script>
</head>
<body>

<h1>Basic control of cart</h1>
<a href="/"><i>Back to Command Central</i></a><p>
<div id="errors""></div>

<div id="arena" onmousedown="arenaClick(event)" ontouchstart="arenaTouch(event)"></div>

</body></html>
